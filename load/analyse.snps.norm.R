##'  Analysis of snps 7.12.2023 
#'  
#' scp filip_kolar@storage-brno12-cerit.metacentrum.cz:brno3/ERC/arenosa_mapped_to_arenosa/filtering_results/annotate.snps/sep.pop.annotated/genotype.counts.tsv .
#'
#' The data were generated by scripts /storage/brno12-cerit/home/filip_kolar/brno3/scripts/load
#' 
#'  4_filter.sh >  pop.snpeff.sh > count_hom_het_snps_norm.sh
#'  From the filtered vcf I used merged.filtered where just GATK BP were used together with our depth and excess het masks
#'  Only in count_hom_het.snps.sh I remove genotypes with depth lower than 8
#'  
#'  The final dataset is subset only the 6 best individuals per population.
#'  
#'  Then classify snps into fitness categories by SnpEff, 
#'  I work with synonymous (SILENT), non-synonymous (MISSENSE) and stop codon gain (NONSENSE)
#'  
#'  The neutral category MODIFIER hits mainly regions away from CDS. 
#'    
#' remove populations with less than 6 inds: 
#' 
#' grep -v "less" genotype.counts.tsv | sponge genotype.counts.tsv
getwd()
setwd("/home/vlkofly/Arabidopsis_science/arenosa/snp_load/snp.norm")
library(tidyverse)
library(ggrepel)
library(scales)
th<-theme(axis.title = element_text(size=23),
          axis.text.y=element_text(size=23,color="black"),
          axis.text.x=element_text(size=23,color="black"),
          plot.title=element_text(size=25),
          legend.text = element_text(size=18),
          strip.text.x = element_text(size = 18),
          panel.background = element_rect(fill = "white", colour = "white"),
          panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(color="black",linetype="solid")
)

indpop<-read.table("genotype.counts.tsv",header=T,sep="\t")
indpop$ploidy<-as.factor(as.character(indpop$ploidy))
summary(indpop)
#indpop<-indpop[!is.na(indpop$dp),] # remove SWD 
indpop$pop<-as.factor(indpop$pop)
indpop$scf<-as.factor(as.character(gsub("scaffold_","",indpop$scf)))
#' the load values were calculated per chromosome, sum it here, only later maybe plot separate chromosomes
#' 

#' check the variance between the scaffolds
#' 
#' Plot the number of sites per scaffold:
svg("sites.per.scaffold.svg")
ggplot(indpop, aes(y=sites_tot/1000,x=scf,colour=ploidy))+
  geom_boxplot()+
  #geom_point(position=position_jitterdodge())+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  ylab("Number of snps/1e3")+
  th
dev.off()
#' **There are more snps in tetraploids**
#' 

#' Plot depth per scaffold
svg("depth.per.scaffold.svg")
ggplot(indpop, aes(y=dp,x=scf,colour=ploidy))+
  geom_boxplot()+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  th
dev.off()
#' This is very similar to the snps where across the whole dataset tets have lower diversity.
#' 

#' Check the effect of depth on the number of snps per scaffold
#' 
svg("snp.No.depth.ploidyperscf.svg")
ggplot(indpop ,aes(x=sites_tot/10000,y=dp,colour=ploidy))+
  geom_point(size=4,pch=16)+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  geom_text(aes(label=pop),size=2.5,check_overlap = F,nudge_y = -2)+
  xlab("Number of snps/1e4")+
  th
dev.off()
#'
#' The two categories or sequencing batches are evident. 
#' 
#' 


names(indpop)
# Let's sum the scaffold values to have a whole genome indices

gen.indpop<- indpop %>% group_by(pop) %>%
  summarise_if(is.numeric,sum) # this would sum all numeric variables, non-numeric are lost

# also for mean depth and number of individuals sum does not make sense, you have to go back to the average so divide by 8
gen.indpop$nind<-gen.indpop$nind/8
gen.indpop$dp<-gen.indpop$dp/8
gen.indpop$dp_raw<-gen.indpop$dp_raw/8

# and add ploidy
gen.indpop<-merge(gen.indpop,indpop[indpop$scf == "1",c("pop","ploidy")],by="pop")
summary(gen.indpop)



#' Check the effect of depth and remove low depth
#' The black line marks cutoff threshold
svg("snp.No.depth.ploidy.y20.y55.all.svg")
ggplot(gen.indpop,aes(x=sites_tot/10000,y=dp,colour=ploidy))+
  geom_point(size=4,pch=16)+
  geom_text(aes(label=pop),size=2.5,check_overlap = F,nudge_x = +6)+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  geom_hline(yintercept=20,colour="red")+
  geom_hline(yintercept=55,colour="red")+
  #geom_hline(yintercept=22,colour="blue")+
  xlab("Number of snps/1e4")+
  ylab("Depth of coverage")+
  th
dev.off()
#' Well ideally I need the same set of samples as in indels
#' With the missing sites removed the depth increased, so I would need to change the threshold
#'
svg("snp.No.depth.ploidy.y20.y55.noSUB.svg")
ggplot(gen.indpop[gen.indpop$dp<55,],aes(x=sites_tot/10000,y=dp,colour=ploidy))+
  geom_point(size=4,pch=16)+
  geom_text(aes(label=pop),size=2.5,check_overlap = F,nudge_x = +6)+
  geom_hline(yintercept=20,colour="black")+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  xlab("Number of snps/1e4")+
  ylab("Depth of coverage")+
  th
dev.off()
#'
#'BGS, KAS, TRE, GUL and VYR are extra tetraploid population that I should remove by setting tetraploid threshold to 22 
#'Otherwise the plot is notably similar to indels,  
#' 
#' Check the sfs to decide what populations to include
#' 

svg("snp.No.depth.ploidy.dp20.svg")
ggplot(gen.indpop[gen.indpop$dp>20 & gen.indpop$dp < 55,],aes(x=sites_tot/10000,y=dp,colour=ploidy))+
  geom_point(size=4,pch=16)+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  geom_text(aes(label=pop),size=2.5,check_overlap = F,nudge_y = -2)+
  xlab("Number of snps/1e4")+
  ylab("Depth of coverage")+
  th
dev.off()

#' So for subsequent analysis I choose only populations with dp between 20 and 55.
#' 22 is minimum dp for tetraploids
#' No I will just select 20
#' 
#' 
pop20<-read.table("pop20.txt",col.names = "pop")
gen.indpop20<- gen.indpop %>% 
  filter(pop %in% pop20$pop)





#gen.indpop20<- gen.indpop %>% 
#   filter(dp > 20 & dp < 50)

summary(gen.indpop20)   

svg("snp.No.depth.ploidy.subset.svg")
ggplot(gen.indpop20,aes(x=sites_tot/10000,y=dp,colour=ploidy))+
  geom_point(size=4,pch=16)+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  geom_text(aes(label=pop),size=2.5,check_overlap = F,nudge_y = -2)+
  xlab("Number of snps/1e4")+
  ylab("Depth of coverage")+
  th
dev.off()

#' Like this I have 12 diploid and 15 tetraploid populations to work with
#' 

#' Is there a difference in depth of coverage between the ploidies?
#' 
svg("depth.ploidy.subset.svg")
ggplot(gen.indpop20,aes(x=ploidy,y=dp,fill=ploidy))+
  geom_boxplot()+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  ylab("Depth of coverage")+
  geom_point(pch=21,size=2,position=position_jitterdodge(),alpha=0.8)+
    th
dev.off()

dp.wilcox<-wilcox.test(gen.indpop20[gen.indpop20$ploidy==2,"dp"],gen.indpop20[gen.indpop20$ploidy==4,"dp"])
print(dp.wilcox) 
# Depth of coverage is slightly higher in teraploids, however the difference is not statistically significant. 

#' **Is there a difference in total number of snps between diploids and tetraploids?**

svg("total.snp.ploidy.svg")
ggplot(gen.indpop20,aes(x=ploidy,y=sites_tot/10000,fill=ploidy))+
  ylab("Number of snps/1e4")+
  geom_boxplot()+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  geom_text(aes(label=pop),size=4,check_overlap = T,nudge_x = 0.2)+
  geom_point(pch=21,size=2,position=position_jitterdodge(),alpha=0.8)+
  th
dev.off()
#' First I will test the difference with Wilcox test
tot.wilcox<-wilcox.test(gen.indpop20[gen.indpop20$ploidy==2,"sites_tot"],gen.indpop20[gen.indpop20$ploidy==4,"sites_tot"])
print(tot.wilcox) 
#' The difference between the cytotypes is statistically significant
#' 
#' But these numbers of snps are actually all numbers considering also major alleles
#' 
#' It might be a problem to count also major alleles because most of them might be ancestral
#' 
#' And I want to count only derived alleles
#' 
#' For that purpose I selected only minor alleles --max-ac 6/12 diploid/tetraploid

svg("total.minor.snp.ploidy.svg")
ggplot(gen.indpop20,aes(x=ploidy,y=minor_sites_tot/10000,fill=ploidy))+
  ylab("Number of minor snps/1e4")+
  geom_boxplot()+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  geom_text(aes(label=pop),size=4,check_overlap = T,nudge_x = 0.2)+
  geom_point(pch=21,size=2,position=position_jitterdodge(),alpha=0.8)+
  th
dev.off()
#' The difference gets even more pronounced
#' 
#' What is actually the distribution of the number of snps?
svg("distribution.minor.snps.svg")
ggplot(gen.indpop20,aes(x=minor_sites_tot/1e4,fill=ploidy))+
  xlab("Number of snps/1e4")+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  
  geom_density(alpha=.5)+
  th
dev.off()
#' This does not seem like gausiann distr. lets use poisson in the models
#' I would like to test the effect of ploidy with depth as a covariate?
sites_tot.glm<-glm(minor_sites_tot~ploidy,data=gen.indpop20, family="poisson")
summary(sites_tot.glm) 
#' This is highly significant

sites_tot_dp.glm<-glm(minor_sites_tot~ploidy*dp,data=gen.indpop20, family="poisson")
summary(sites_tot_dp.glm) 
#' This is significant as well
#' 
#' Is the model with dp better?
anova(sites_tot.glm,sites_tot_dp.glm,test="LRT") # what test to use with poisson? 
#' Of course the model with explains much more, but still the effect of ploidy is significant
#' I should consider the effect of depth in each step of the analysis
#' 

svg("minor.snp.depth.ploidy.svg")
ggplot(gen.indpop20,aes(x=minor_sites_tot/1e4,y=dp,colour=ploidy))+
  geom_point(size=4,pch=16)+
  scale_colour_manual(values=c("#1e90ff","#ffa500"))+
  geom_text(aes(label=pop),size=2.5,check_overlap = F,nudge_y = -2)+
  xlab("Number of snps/1e4")+
  ylab("Depth of coverage")+
  th
dev.off()
#' The effect of depth seems actually less pronounced in minor snps
#' 
#' Conclusion from the  total snp analysis is that tetraploids accumulate on average more snps than diploids.
#'
#' Mean values per ploidy: 
sum.per.ploidy<-gen.indpop20 %>%
  group_by(ploidy)%>%
  summarise(across(where(is.numeric),list(mean=mean,sd=sd,median=median))) %>%
  as.matrix() %>% t() %>% as.data.frame()
names(sum.per.ploidy) <- c("diploid","tetraploid")
print(sum.per.ploidy)
write.table(sum.per.ploidy,"ploidy.average.tsv",sep="\t",quote=F)
#' There is not much difference in mean depth 32.04/34.20 and its standard deviation.
#' 
#' Mean total number of snps is 1.31M/1.97M
#' Mean total number of minor snps is 0.91M/1.61M
#'___________________________________________________________________
#'
##' Let's focus on the two fitness categories of snps silent and missense
#'  The point is to test whether tetraploids not only accumulate more of snps
#'  but also if they accumulate more deleterious snps which are in the MISSENSE
#'  category. For this analysis one must take the assumption that the total numbers
#'  of MISSENSE snps are only negligibly affected by adaptive selection.
#'  I think it is well satisfied assumption given that I work with only minor allele snps 
#'  
#'  Let's see the distribution of MISSENSE and SILENT snps per ploidy
head(gen.indpop20)
#' High effect first, they are of course in minority
svg("missense.N.snp.ploidy.svg")
ggplot(gen.indpop20,aes(x=ploidy,y=MISSENSE_tot_minor/1e4,fill=ploidy))+
  ylab("Number of non-synonym. snps/1e4")+
  geom_boxplot()+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  geom_point(pch=21,size=2,position=position_jitterdodge(),alpha=0.8)+
  geom_text(aes(label=pop),size=3,check_overlap = T,nudge_x = 0.2)+
  th
dev.off()
#' 
#' But overall the effect of ploidy is evident even in highly deleterious snps
#' 
#' Here I have an idea of counting the load per individual and get also variance at within population level
#' 
#' What if I check the dataset also with major alleles?
#' 
svg("missense.N.all.snp.ploidy.svg")
ggplot(gen.indpop20,aes(x=ploidy,y=MISSENSE_tot/1e4,fill=ploidy))+
  ylab("Number of non-synonym. snps/1e4")+
  geom_boxplot()+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  geom_point(pch=21,size=2,position=position_jitterdodge(),alpha=0.8)+
  geom_text(aes(label=pop),size=3,check_overlap = T,nudge_x = 0.2)+
  th
dev.off()
#' 
#' 
#' synonymous alleles: 
#' 
svg("modif.N.snp.ploidy.svg")
ggplot(gen.indpop20,aes(x=ploidy,y=SILENT_tot_minor/1e4,fill=ploidy))+
  ylab("Number of synonym. snps/1e4")+
  geom_boxplot()+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  geom_point(pch=21,size=2,position=position_jitterdodge(),alpha=0.8)+
  geom_text(aes(label=pop),size=3,check_overlap = T,nudge_x = 0.2)+
  th
dev.off()
#' 
#' Is it statistically significant?
modif.wilcox<-wilcox.test(gen.indpop20[gen.indpop20$ploidy==2,"SILENT_tot_minor"],gen.indpop20[gen.indpop20$ploidy==4,"SILENT_tot"])
print(modif.wilcox)
missense.wilcox<-wilcox.test(gen.indpop20[gen.indpop20$ploidy==2,"MISSENSE_tot_minor"],gen.indpop20[gen.indpop20$ploidy==4,"MISSENSE_tot"])
print(missense.wilcox)
#' Yes of course, now include dp as covariate
sites_high_dp.glm<-glm(MISSENSE_tot_minor~ploidy*dp,data=gen.indpop20, family="poisson")
summary(sites_high_dp.glm)
#' It is still significant 
sites_low_dp.glm<-glm(SILENT_tot_minor~ploidy*dp,data=gen.indpop20, family="poisson")
summary(sites_low_dp.glm)
#' This is highly significant
#' Now I want to understand if the tets accumulate proportionally more higly deleterious
#' First check the ratio missense/silent
gen.indpop20$hm.tm<-gen.indpop20$MISSENSE_tot_minor/gen.indpop20$minor_sites_tot
svg("missense.tot.minor.ratio.ploidy.svg")
ggplot(gen.indpop20,aes(x=ploidy,y=hm.tm,fill=ploidy))+
  ylab("Non-synonym./total snps")+
  geom_boxplot()+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  geom_point(pch=21,size=2,position=position_jitterdodge(),alpha=0.8)+
  geom_text(aes(label=pop),size=4,check_overlap = F,nudge_x = 0.2)+
  th
dev.off()
#' This is higher in tatraploids, do they accumulate proportionally more high effect snps?
#' Is this difference significant?
svg("distribution.hm.tm.ratio.svg")
ggplot(gen.indpop20,aes(x=hm.tm,fill=ploidy))+
  xlab("Non-synonym./Total snps")+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  geom_density(alpha=.5)+
  th
dev.off()

ratio.hm.tm_dp.glm<-glm(hm.tm~ploidy+dp,data=gen.indpop20, family="gaussian")
summary(ratio.hm.tm_dp.glm)

#' This is not significant in glm 

hm.tm.wilcox<-wilcox.test(gen.indpop20[gen.indpop20$ploidy==2,"hm.tm"],gen.indpop20[gen.indpop20$ploidy==4,"hm.tm"])
print(hm.tm.wilcox)

#' And Wilcox is not significant either

#' I guess it will be the same for high/weak effect snps?
#' 
gen.indpop20$hm.wm<-gen.indpop20$MISSENSE_tot_minor/gen.indpop20$SILENT_tot_minor

svg("missense.silent.ratio.ploidy.svg")
ggplot(gen.indpop20,aes(x=ploidy,y=hm.wm,fill=ploidy))+
  ylab("Non-synonym/Synonym. snps")+
  geom_boxplot()+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  geom_point(pch=21,size=2,position=position_jitterdodge(),alpha=0.8)+
  geom_text(aes(label=pop),size=3,check_overlap = T,nudge_x = 0.2)+
  th
dev.off()

ratio.hm.wm_dp.glm<-glm(hm.wm~ploidy,data=gen.indpop20, family="gaussian")
summary(ratio.hm.wm_dp.glm)
#' This is significant with dp or without, dp itself is not significant
#' 
#' 


 
#' **I will try a different approach**
#' I take the number of synonymous snps as a background rate of snp insertion
#' 
#' Compare if an increase in synonymous snps leads to proportional increase in non-synonymous effect snps
#' 
#' If the slope of correlation between high and weak snps is steeper in tets
#' 
#' It would signify that tets accumulate proportionally more deleterious load  
#' This figure will be the main figure of the paper. 
svg("missenseN.silentN.ploidy.svg")
ggplot(gen.indpop20,aes(x=SILENT_tot_minor/1e4,y=MISSENSE_tot_minor/1e4,fill=ploidy))+
  ylab("Non-synonymous snps/1e4")+
  xlab("Synonymous snps/1e4")+
  geom_smooth(method=lm,colour="black")+
  geom_point(pch=21,size=4,alpha=1)+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  geom_text(aes(label=pop),size=3,check_overlap = T,nudge_x = -2)+
  th
dev.off()

#' Maybe create one figure with the population names with ggrepel
#' Some good examples are here https://ggrepel.slowkow.com/articles/examples.html
library(cowplot)
library(ggrepel)

svg("missenseN.silentN.lm.ploidy.repel.svg")
ggplot(gen.indpop20,aes(x=SILENT_tot_minor/1e4,y=MISSENSE_tot_minor/1e4,fill=ploidy,color=ploidy))+
  ylab("Non-synonymous sites/1e4")+
  xlab("Synonymous sites/1e4")+ # call it synonymous sites and for additive load I will call it synonymous allelels
  geom_smooth(method="glm",linewidth=1,method.args = list(family = "gaussian"))+
  geom_point(pch=21,size=4,alpha=1,color="black")+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  geom_text_repel(aes(label=pop),min.segment.length = 0, size=3,point.padding = 0.01,box.padding = 0.6,max.overlaps = 15,direction = "both",color="black")+
  th
dev.off()

#' This is a way how to test whether the regression slopes differ, interaction
himo0.glm<-glm(MISSENSE_tot_minor~SILENT_tot_minor+ploidy,family="poisson",data=gen.indpop20)
himo.glm<-glm(MISSENSE_tot_minor~SILENT_tot_minor*ploidy,family="poisson",data=gen.indpop20)
anova(himo0.glm,himo.glm,test="LRT")
#' The interaction of ploidy and the number of weak (SILENT)  snps is significant
#' Is it significant even if I add depth as a fixed factor?
#' 
himo0.dp.glm<-glm(MISSENSE_tot_minor~SILENT_tot_minor+ploidy+dp,family="poisson",data=gen.indpop20)
himo.dp.glm<-glm(MISSENSE_tot_minor~SILENT_tot_minor*ploidy+dp,family="poisson",data=gen.indpop20)
anova(himo0.dp.glm,himo.dp.glm,test="LRT")
summary(himo.dp.glm)
#' this is still significant, so I will probably use this model as the final one


#' What about some other fitness classes of snps
#' snps causing premature stop codon
svg("stop.codon.minor.snp.ploidy.svg")
ggplot(gen.indpop20,aes(x=ploidy,y=NONSENSE_tot_minor/1e3,fill=ploidy))+
  ylab("Number of nonsense sites/1e3")+
  geom_boxplot()+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  geom_point(pch=21,size=2,position=position_jitterdodge(),alpha=0.8)+
  geom_text_repel(aes(label=pop),size=3,point.padding = 0.01,box.padding = 0.1,max.overlaps = 6,direction = "both",color="black")+
  th
dev.off()

nonsense.wilcox<-wilcox.test(gen.indpop20[gen.indpop20$ploidy==2,"NONSENSE_tot_minor"],gen.indpop20[gen.indpop20$ploidy==4,"NONSENSE_tot_minor"])
print(nonsense.wilcox)
#' Introns show significant difference between ploidies
#' now include dp as covariate
sites_intron_dp.glm<-glm(NONSENSE_tot_minor~ploidy*dp,data=gen.indpop20, family="poisson")
sites_intron_dp.glm0<-glm(NONSENSE_tot_minor~1+dp,data=gen.indpop20, family="poisson")
anova(sites_intron_dp.glm0,sites_intron_dp.glm,test="LRT")
# it is super significant difference even if dp included
summary(sites_intron_dp.glm)

#' The correlation nonsense vs. synonym
#' 
svg("nonsenseN.synonymousN.ploidy.svg")
ggplot(gen.indpop20,aes(y=NONSENSE_tot_minor/1e3,x=SILENT_tot_minor/1e3,fill=ploidy,color=ploidy))+
  ylab("Nonsense sites/1e3")+
  xlab("Synonymous sites/1e3")+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  geom_point(pch=21,size=4,alpha=1,color="black")+
  geom_smooth(method=lm)+
  geom_text_repel(aes(label=pop),min.segment.length = 0, size=3,point.padding = 0.01,box.padding = 0.6,max.overlaps = 15,direction = "both",color="black")+
  th
dev.off()

hiint.glm<-glm(NONSENSE_tot~SILENT_tot_minor*ploidy,family="poisson",data=gen.indpop20)
summary(hiint.glm)

hiin0.dp.glm<-glm(NONSENSE_tot~SILENT_tot_minor+ploidy+dp,family="poisson",data=gen.indpop20)
hiin.dp.glm<-glm(NONSENSE_tot~SILENT_tot_minor*ploidy+dp,family="poisson",data=gen.indpop20)
anova(hiin0.dp.glm,hiin.dp.glm,test="LRT")
summary(hiin.dp.glm)
#' The interaction of ploidy and synonymous sites is significant tetraploids also accumulate more premature stop codons


#' Check relationship between synonymous sites and MODIFIER sites, which are mainly non-coding variants. Upstream Downstream. default snpeff up and downstream is 5kbp
#' 
svg("synonymousN.modifierN.ploidy.svg")
ggplot(gen.indpop20,aes(y=SILENT_tot_minor/1e4,x=WEAK_tot_minor/1e4,fill=ploidy,color=ploidy))+
  ylab("Synonymous sites/1e4")+
  xlab("Modifier sites/1e4")+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  geom_point(pch=21,size=4,alpha=1)+
  geom_smooth(method=lm)+
  geom_text_repel(aes(label=pop),min.segment.length = 0, size=3,point.padding = 0.01,box.padding = 0.6,max.overlaps = 15,direction = "both",color="black")+
  th
dev.off()
#' Synonymous vs. non-coding gives an opposite pattern in terms of accumulation of synoymous as more selected category. The diploids have less synonymous and modifier sites but they accumulate
#' pproportionally more synonymous sites compared to diploids.

moin0.glm<-glm(SILENT_tot_minor~WEAK_tot_minor+ploidy+dp,family="poisson",data=gen.indpop20)
moin.glm<-glm(SILENT_tot_minor~WEAK_tot_minor*ploidy+dp,family="poisson",data=gen.indpop20)
anova(moin0.glm,moin.glm,test="LRT")
summary(moin.glm)


#' 
#' **The conclusion is that the effect of ploidy affects both total numbers and also accumulation**
#' **of strongly deleterious snps. Tetraploids accumulate more and more deleterious** 

##' The last chapter deals with actual load indicators as designed for human data by Simons and Sella
#' It is based on counting of genotypes
#' 

#' I'm comparing the slope similar as above, this time for high vs. weak effect heterozygous genotypes
#' Tets have higher proportion of heterozygots 1-p^2+q^2, I'm counting all dosages 0/0/0/1 0/0/1/1/ 0/1/1/1
#' I don't know if I should go into the genotype counts, it is rather confusing
#' 
#' This is the heterozygous genotypes for diploids:
#'  MISSENSE_het=`grep MISSENSE $vcf |cut -f 10-16|grep -E -o "0/1" | wc -l`
#'  And for tetraploids
#'  MISSENSE_het=`grep MISSENSE $vcf |cut -f 10-16|grep -E -o "0/0/0/1|0/1/1/1|0/0/1/1" | wc -l` 

svg("MISSENSE_het.SILENT_het.ploidy.svg")
ggplot(gen.indpop20,aes(x=SILENT_het/1e4,y=MISSENSE_het/1e4,fill=ploidy,color=ploidy))+
  ylab("Non-synonym. het. gen./1e4")+
  xlab("Synonym. het. gen./1e4")+
  geom_point(pch=21,size=3,alpha=0.5)+
  geom_smooth(method=lm)+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  geom_text_repel(aes(label=pop),min.segment.length = 0, size=3,point.padding = 0.01,box.padding = 0.6,max.overlaps = 15,direction = "both",color="black")+
  th
dev.off()
#' Tetraploids have higher "concealed load" load that is in heterozygous genotypes, compared to diploids.
#' It is because they have higher heterozygosity due to HW and tetrasomic inheritance.
#' The question is whether they also accumulate proportionally more deleterious "concealed load"?
#' 
#' First lets test the difference
missense.het.wilcox<-wilcox.test(gen.indpop20[gen.indpop20$ploidy==2,"MISSENSE_het"],gen.indpop20[gen.indpop20$ploidy==4,"MISSENSE_het"])
print(missense.het.wilcox)

#' Now the slope without depth
het.glm0<-glm(MISSENSE_het~SILENT_het+ploidy,family="poisson",data=gen.indpop20)
het.glm<-glm(MISSENSE_het~SILENT_het*ploidy,family="poisson",data=gen.indpop20)
anova(het.glm,het.glm0,test="LRT")
summary(het.glm)
#' Yes it is significant
#' is it significant even with depth
het.dp.glm0<-glm(MISSENSE_het~SILENT_het+ploidy+dp,family="poisson",data=gen.indpop20)
het.dp.glm<-glm(MISSENSE_het~SILENT_het*ploidy+dp,family="poisson",data=gen.indpop20)
anova(het.dp.glm,het.dp.glm0,test="LRT")
summary(het.dp.glm)
#' Yes so even with depth included the interaction between ploidy and number of weak effect snps 
#' 

#' Homozygous genotypes = expressed load:
svg("MISSENSE_hom.SILENT_hom.ploidy.svg")
ggplot(gen.indpop20,aes(x=SILENT_hom/1e3,y=MISSENSE_hom/1e3,fill=ploidy,colour=ploidy))+
  ylab("Non-synonym hom. gen./1e3")+
  xlab("Synonym hom. gen./1e3")+
  geom_point(pch=21,size=3,alpha=0.5)+
  geom_smooth(method=lm)+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  geom_text_repel(aes(label=pop),min.segment.length = 0, size=3,point.padding = 0.01,box.padding = 0.6,max.overlaps = 15,direction = "both",color="black")+
  th
dev.off()
#' Here the diploids have much higher expressed load and it seems that tetraploids accumulate proportionally more
hom.dp.glm0<-glm(MISSENSE_hom~SILENT_hom+ploidy+dp,family="poisson",data=gen.indpop20)
hom.dp.glm<-glm(MISSENSE_hom~SILENT_hom*ploidy+dp,family="poisson",data=gen.indpop20)
anova(hom.dp.glm,hom.dp.glm0,test="LRT")
summary(hom.dp.glm)
#' also the interaction is significant, tetraploids seem to accumulate more
#' I have to check how to calculate the slope
#' 
summary(lm(MISSENSE_hom~SILENT_hom*ploidy+dp,data=gen.indpop20))



#' Just to show what proportion of high effect snps is in what genotype per ploidy
svg("MISSENSE_het.MISSENSE_hom.ploidy.svg")
ggplot(gen.indpop20,aes(x=MISSENSE_hom/1e4,y=MISSENSE_het/1e4,fill=ploidy))+
  ylab("High het snps/1e4")+
  xlab("High hom snps/1e4")+
  geom_point(pch=21,size=4,alpha=1)+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  #geom_text(aes(label=pop),size=3,check_overlap = F,nudge_x = 1)+
  #geom_smooth(method=lm)+
  th
dev.off()

svg("SILENT_het.SILENT_hom.ploidy.svg")
ggplot(gen.indpop20,aes(x=SILENT_hom/1e4,y=SILENT_het/1e4,fill=ploidy))+
  ylab("Weak het snps/1e4")+
  xlab("Weak hom snps/1e4")+
  geom_point(pch=21,size=4,alpha=1)+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  #geom_text(aes(label=pop),size=3,check_overlap = F,nudge_x = 1)+
  #geom_smooth(method=lm)+
  th
dev.off()

#' Plot additive load, for this index I summed upped all alleles present in population
#' MISSENSE_additive=`echo "$MISSENSE_het+$MISSENSE_hom*2" |bc` this is for diploid
#' And this for tetraploid
#' MISSENSE_het1=`grep MISSENSE $vcf |cut -f 10-16|grep -E -o "0/0/0/1" | wc -l`  dosage1
#' MISSENSE_het2=`grep MISSENSE $vcf |cut -f 10-16|grep -E -o "0/0/1/1" | wc -l`  dosage2
#' MISSENSE_het3=`grep MISSENSE $vcf |cut -f 10-16|grep -E -o "0/1/1/1" | wc -l`  dosage3
#' MISSENSE_additive=`echo "$MISSENSE_het1+$MISSENSE_het2*2+$MISSENSE_het3*3+$MISSENSE_hom*4" |bc`


svg("MISSENSE_additive.SILENT_additive.ploidy.svg")
ggplot(gen.indpop20,aes(y=MISSENSE_additive/1e4,x=SILENT_additive/1e4,fill=ploidy,color=ploidy))+
  xlab("Synonymous alleles/1e4")+
  ylab("Non-synonymous alleles/1e4")+
  geom_point(pch=21,size=3,alpha=0.3)+
  geom_text_repel(aes(label=pop),min.segment.length = 0, size=3,point.padding = 0.01,box.padding = 0.6,max.overlaps = 15,direction = "both",color="black")+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  geom_smooth(method=lm)+
  th
dev.off()
#' If the snps are additive the genetic load is higher in tetraploids
#' If the snps are recessive the genetic load is higher in diploids
#' For the additive load it seems it follows the same line as total numbers 
#' In the sense that tetraploids accumulate proportionally more deleterious load



#' one idea maybe just for visualization divide the number of allele by 2
#' to see the difference in the slope
gen.indpop20$ploidy
str(as.numeric(gen.indpop20$MISSENSE_additive/2))
#there is probably some dplyr solution
gen.indpop20<-gen.indpop20 %>% 
  mutate(MISSENSE_additive_scaled = ifelse(ploidy == '4', round((MISSENSE_additive / 2),digits=0), MISSENSE_additive),
         SILENT_additive_scaled = ifelse(ploidy == '4', round((SILENT_additive / 2),digits=0), SILENT_additive))

str(gen.indpop20$SILENT_additive_scaled)                                          
svg("MISSENSE_additive.SILENT_additive.scaled.tets.ploidy.svg")
ggplot(gen.indpop20,aes(y=MISSENSE_additive_scaled/1e4,x=SILENT_additive_scaled/1e4,fill=ploidy,colour=ploidy))+
  ylab("Non-synonymous alleles/1e4")+
  xlab("Synonymous alleles/1e4")+
  geom_point(pch=21,size=3,alpha=0.5)+
  geom_smooth(method=lm)+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  geom_text_repel(aes(label=pop),min.segment.length = 0, size=3,point.padding = 0.01,box.padding = 0.6,max.overlaps = 15,direction = "both",color="black")+
  th
dev.off()
#' OK the difference is clear I think this is also one of the main picture that should go to the text
#' Let's test the significance
additive.dp.glm0<-glm(MISSENSE_additive~SILENT_additive+ploidy+dp,family="poisson",data=gen.indpop20)
additive.dp.glm<-glm(MISSENSE_additive~SILENT_additive*ploidy+dp,family="poisson",data=gen.indpop20)
anova(additive.dp.glm,additive.dp.glm0,test="LRT")
summary(additive.dp.glm)
#' If I test it as gaussian then the interaction is not significant.
#' I had to round the scaled additive load to the nearest integer and then it is significant


#' For the main figure I would chose the sites and additive load in an inset
#' Well Filip does not like the idea, so I will do it only with total numbers
#' 
#' I need to fix the axis labels use package scales: https://bookdown.org/Maxine/ggplot2-maps/posts/2019-11-27-using-scales-package-to-modify-ggplot2-scale/

# this theme will be shared with Tuomas
th<-theme(axis.title = element_text(size=23),
          axis.text.y=element_text(size=23,color="black"),
          axis.text.x=element_text(size=23,color="black"),
          plot.title=element_text(size=25),
          legend.text = element_text(size=18),
          strip.text.x = element_text(size = 18),
          panel.background = element_rect(fill = "white", colour = "white"),
          panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(color="black",linetype="solid")
)

# get the slope of correlation beta and print it in the figure

lmdnds<-lm(MISSENSE_tot_minor~SILENT_tot_minor*ploidy,data=gen.indpop20) # should I do it with dp or without
summary(lmdnds)
lmdnds$coefficients
coef(lmdnds)

# do it in separate models and scale the data

gen.indpop20$MISSENSE_tot_minor_scaled<-scale(gen.indpop20$MISSENSE_tot_minor)
gen.indpop20$SILENT_tot_minor_scaled<-scale(gen.indpop20$SILENT_tot_minor)
gen.indpop20$NONSENSE_tot_minor_scaled<-scale(gen.indpop20$NONSENSE_tot_minor)
slodip<-coef(lm(MISSENSE_tot_minor_scaled~SILENT_tot_minor_scaled,data=gen.indpop20[gen.indpop20$ploidy == 2,]))[2]
slotet<-coef(lm(MISSENSE_tot_minor_scaled~SILENT_tot_minor_scaled,data=gen.indpop20[gen.indpop20$ploidy == 4,]))[2]
slodip<-round(slodip,digits=2)
slotet<-round(slotet,digits=2)

lm1<-lm(MISSENSE_tot_minor~SILENT_tot_minor*ploidy,data=gen.indpop20)
summary(lm1)

fig1a<-ggplot(gen.indpop20,aes(x=SILENT_tot_minor,y=MISSENSE_tot_minor,fill=ploidy,color=ploidy))+
  ylab("Non-synonymous snps")+
  xlab("Synonymous snps")+ # call it synonymous sites and for additive load I will call it synonymous alleles
  scale_x_continuous(breaks=c(0.25e6,0.35e6,0.45e6),label = label_number(scale = 1e-6,suffix = "M"))+
  scale_y_continuous(breaks = breaks_pretty(n=4),label = label_number(scale = 1e-6,suffix = "M"))+
  geom_smooth(method="glm",linewidth=1,method.args = list(family = "gaussian"))+
  geom_point(pch=21,size=4,alpha=0.7,color="black")+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  geom_text_repel(aes(label=pop),min.segment.length = 0, size=3,point.padding = 0.01,box.padding = 0.6,max.overlaps = 15,direction = "both",color="black")+
  #geom_text(aes(39e4,17e4,label=paste("\u03B2","=",as.character(slodip),sep="")),color="#1e90ff",size=7)+
  #geom_text(aes(46e4,17e4,label=paste("/",as.character(slotet),sep="")),color="#ffa500",size=7)+
  th
svg("fig1a.svg.label.svg")
print(fig1a)
dev.off()
saveRDS(fig1a,"snp.load.fig.rds") # eventually you will put all the figures together from snp and indels


##figure 1 b will be stop codons
slodip<-coef(lm(NONSENSE_tot_minor_scaled~SILENT_tot_minor_scaled,data=gen.indpop20[gen.indpop20$ploidy == 2,]))[2]
slotet<-coef(lm(NONSENSE_tot_minor_scaled~SILENT_tot_minor_scaled,data=gen.indpop20[gen.indpop20$ploidy == 4,]))[2]
slodip<-round(slodip,digits=3)
slotet<-round(slotet,digits=3)



fig1b<-ggplot(gen.indpop20,aes(y=NONSENSE_tot_minor,x=SILENT_tot_minor,fill=ploidy,color=ploidy))+
  ylab("Nonsense snps")+
  xlab("Synonymous snps")+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  scale_y_continuous(breaks = breaks_pretty(n=4),label = label_number(scale = 1e-3,suffix = "K"))+
  scale_x_continuous(breaks = c(0.25e6,0.35e6,0.45e6),label = label_number(scale = 1e-6,suffix = "M"))+
  geom_point(pch=21,size=4,alpha=0.7,color="black")+
  geom_smooth(method=lm,linewidth=1)+
  geom_text_repel(aes(label=pop),min.segment.length = 0, size=3,point.padding = 0.01,box.padding = 0.6,max.overlaps = 15,direction = "both",color="black")+
  #geom_text(aes(39e4,1500,label=paste("\u03B2","=",as.character(slodip),sep="")),color="#1e90ff",size=7)+
  #geom_text(aes(47e4,1500,label=paste("/",as.character(slotet),sep="")),color="#ffa500",size=7)+
  th

svg("fig1b.slope.label.svg")
print(fig1b)
dev.off()

saveRDS(fig1b,"snp.nonsense.load.fig.rds") # eventually you will put all the figures together from snp and indels


fig1b<-ggplot(gen.indpop20,aes(y=MISSENSE_additive_scaled/1e4,x=SILENT_additive_scaled/1e4,fill=ploidy,colour=ploidy))+
  ylab("dN alleles/1e4")+
  xlab("dS alleles/1e4")+
  #ggtitle("Alleles")+
  geom_smooth(method=lm,linewidth=0.5)+
  geom_point(pch=21,size=2,alpha=0.5,color="black")+
  scale_fill_manual(values=c("#1e90ff","#ffa500"))+
  scale_color_manual(values=c("#1e90ff","#ffa500"))+
  theme(axis.text.x=element_text(size = 10),
        axis.title = element_text(size=10),
        axis.text.y=element_text(size=10),
        legend.text = element_blank(),
        legend.position = "none")
  
svg("main.figure.snp.load.svg")
fig1a+ annotation_custom(ggplotGrob(fig1b), xmin = 40, xmax = 56, 
                             ymin = 10.5, ymax = 23)

dev.off()
##f

snp.load.fig<-fig1a+ annotation_custom(ggplotGrob(fig1b), xmin = 40, xmax = 56, 
                         ymin = 10.5, ymax = 23)

saveRDS(fig1a,"snp.load.fig.rds") # eventually you will put all the figures together from snp and indels

